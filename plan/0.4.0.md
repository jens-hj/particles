# 0.4.0 Plan — Picking + Atom Detection

## Goals
- Add interactive particle picking that re-centers the camera on the picked particle’s position.
- Add GPU-assisted “atom detection” on top of the existing hadron detection and show atoms in the renderer + a periodic-table-like “atom card” UI.

## Non-goals (for 0.4.0)
- Full chemistry (molecule detection, covalent bond graphs, etc.).
- Perfect physical correctness of orbital mechanics; we’ll focus on robust detection + visualization first.

---

## Feature 1 — Clickable particles + camera focus/reset

### UX requirements
- Left-click selects the nearest visible particle under the cursor.
- Camera re-centers to focus on the selected particle’s instantaneous position. (Thus depending on the zoom level, you can pick either quarks when you're close, hadrons a bit further away, and atoms when even further away.)
- Press `C` to reset camera focus back to the world origin (and clear selection).

### Implementation steps
1. **Picking ray**: convert mouse cursor -> world ray using camera projection/view.
2. **GPU picking pass (preferred)**:
   - Render particle IDs into a small offscreen texture (integer/uint target or encoded RGBA) using the existing particle draw path.
   - Read back 1 pixel (or a small region) on click to get the particle index.
   - Pros: fast, works with depth/occlusion.
3. **Fallback CPU picking (acceptable early)**:
   - Read back a *small* subset of particle positions (or the whole buffer rarely) and do ray/point distance checks.
   - Only as an interim solution; avoid per-frame readback.
4. **Camera focus**:
   - Store `camera_focus_mode` and `focused_entity` (None | Particle(u32) | Hadron(u32) | Atom(u32)).
   - Each frame, update camera target position from the chosen entity’s center.
5. **Reset keybind**:
   - In the winit event handler, `C` sets focus to origin and clears selection.

### Deliverables
- Selection highlight in renderer (e.g., outline/glow on selected particle).
- Camera smoothly lerps to new center (avoid instant snapping).

### Risks / questions
- Decide: should click select atom/hadron shells too, or only particles for now?
  - These should be selectable when they are visible, which depends on how close the camera is to the subject: particles (quarks, electrons), hadrons (proton shells, neutron shells, meson shells), atoms (nucleon shells).

---

## Feature 2 — Atom detection (+ visualization + atom card UI)

### Definition: what is an “atom” in this sim?
- A nucleus = cluster of *nucleons* (protons + neutrons) bound by residual strong force (already modeled).
- An atom = a nucleus plus a set of electrons considered “bound” to that nucleus via EM interaction.
- We will treat nuclei and atoms as **derived/composite entities** like hadrons.

### Data model (new)
- New `Atom` storage buffer (similar layout to `Hadron` but nucleus-level):
  - `nucleon_indices` (fixed max, or compact list via an index buffer)
  - `electron_indices` (fixed max, or list)
  - `proton_count`, `neutron_count`, `electron_count`
  - `charge`
  - `center.xyz` + `radius`
  - `type_id` / `atomic_number` (Z = proton_count)
- New `AtomCounter` buffer:
  - total atoms
  - (optional) per-element histogram later

### Detection pipeline overview
We’ll likely do this as **GPU compute passes**, mirroring hadrons:

1. **Nucleus detection** (from hadrons/nucleons)
   - Inputs: hadron buffer (protons/neutrons/other) + particle buffer.
   - Detect clusters of nucleons where inter-nucleon distances < threshold AND relative velocities are low enough (stability heuristic).
   - Produce nucleus objects (or directly “atom cores”) with:
     - list of nucleons
     - center of mass
     - Z/N
     - radius

2. **Electron binding detection**
   - For each electron, assign it to the “best” nucleus if:
     - within some binding radius (dependent on Z maybe)
     - and its kinetic energy / speed is below a threshold relative to the nucleus potential (heuristic)
   - Alternatively: assign by minimum (distance / Z) score.

3. **Atom assembly**
   - Combine nucleus + assigned electrons => Atom.
   - Compute total charge: `Z - electron_count` (assuming electron charge -1, proton +1).
   - Determine element name by Z (periodic table map on CPU side for UI; GPU can store Z only).

### Visuals
- Render an **atom shell** around atom center with radius based on:
  - nucleus radius + electron binding radius estimate
  - or a param-driven value scaled by Z
- Color:
  - Base on **CPK colors** per element (H white, C black/gray, O red, N blue, etc.)
  - Then map/tweak into a palette compatible with Catppuccin (e.g. constrain saturation/value).
  - Implementation: CPU lookup table mapping Z -> RGBA (linear space), stored in a small uniform/SSBO.

### UI: Atom “card”
- Show when an atom is selected (via clicking a particle inside it or clicking atom shell later):
  - Element name
  - Atomic number (Z)
  - Neutron count (N)
  - Electron count (e)
  - Net charge
  - Possibly mass number A = Z+N
- Display like a periodic table tile:
  - Large symbol (e.g., “C”)
  - Z in corner, A optional, charge indicator
- Also show “Detected atoms: N” somewhere in main UI.

### Implementation steps (incremental)
1. Move camera orbit center when a particle/hadron is selected.
  - Make sure the orbit center is lerped smoothly to prevent jumpy motion.
2. Add `Atom` structs/types in `particle-physics` crate (mirroring `Hadron`).
3. Add atom buffers and pipelines in `particle-simulation` crate:
   - `atom_detection.wgsl`
   - (optional) `atom_validation.wgsl`
4. Add renderer support in `particle-renderer` crate:
   - `atom.wgsl` similar to `hadron.wgsl` for shell rendering.
5. Make sure atoms are pickable as camera orbit center as well.
6. Add selection plumbing:
   - selecting a particle finds its containing atom (if any) for the atom card.
   - such that even if a sub-particle is selected, the atom card still displays the atom it belongs to.
7. Add periodic-table metadata on CPU side:
   - Z -> {symbol, name, CPK-ish color}
   - Use Catppuccin-friendly adjusted palette.

### Heuristics / parameters to expose
- nucleus clustering distance
- nucleus stability thresholds (relative speed, max spread)
- electron binding distance threshold (possibly function of Z)
- maximum electrons stored per atom (avoid unbounded buffers)

### Risks / questions
- Dynamic membership lists on GPU are tricky; we’ll likely start with fixed max sizes per atom + overflow handling.
- Detection stability: atoms should not flicker membership every frame; we may need hysteresis (bind threshold < unbind threshold).
- Decide: do we treat hadrons of type “other” (mesons) as excluded from nuclei?

---

## Milestones
### M1: Picking + camera focus/reset
- Offscreen ID render + click readback
- Camera focus on selected entity
- `C` reset

### M2: Nucleus detection
- Detect stable nucleon clusters
- Render nucleus/atom core shell

### M3: Electron binding + Atom objects
- Assign electrons to nuclei
- Atom shell rendering + counts

### M4: Atom card UI + styling
- Show periodic-table-like card for selected atom
- CPK-ish colors tuned to Catppuccin

---

## Acceptance criteria
- You can click a particle and the camera centers on its position.
- Pressing `C` returns camera to world origin reliably.
- Simulation detects any known element as an atom.
- Atom shells render with stable colors and don’t flicker heavily.
- UI shows a correct atom card (Z/N/e/charge/name) for the selected atom.
